/*
 * Created on 14-jun-2005
 *
 * Tunelator surveying software.
 * 
 * Copyright (C) 2005 Juan Alvarez Ferrando
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
 * MA  02110-1301, USA.
 * 
 */
package es.tunelator.gui.commands;

import java.util.ArrayList;
import java.util.Iterator;

import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

import es.tunelator.UserMessageException;
import es.tunelator.gui.adv.MainFrame;
import es.tunelator.gui.models.FileNodeUpdater;
import es.tunelator.gui.vo.GUIFileVO;
import es.tunelator.log.Logger;
import es.tunelator.resources.Resourcer;
import es.tunelator.vo.ProfileVO;

/**
 * &COPY; 2005 Juan Alvarez Ferrando<br><br>
 * 
 * Execution of this command deletes a profile from the profile list of a file.
 * 
 * @author <a href="mailto:jaferrando@users.berlios.de">Juan Alvarez Ferrando</a>
 */
public class DeleteProfileCommand implements Command {
    /**
     * The <code>MainFrame</code> where the GUI actions of this command 
     * will be done
     */
    private MainFrame frame = null;
    /**
     * The profiles that have been deleted, toghether with the file to which
     * they belong. Saved to be able to undo the command.
     */
    private ArrayList items = new ArrayList();
    /**
     * &COPY; 2005 Juan Alvarez Ferrando<br><br>
     * 
     * Holds the data needed from a deleted profile to be able to eventally 
     * perform the undo operation. It's the pait of the profile and a reference
     * to the file to which it belongs.
     * 
     * @author <a href="mailto:jaferrando@users.berlios.de">Juan Alvarez Ferrando</a>
     */
    private class DeletedItem {
        /**
         * <code>file</code> (<code>GUIFileVO</code>) the file where the profile was deleted from
         */
        public GUIFileVO file = null;
        /**
         * <code>profile</code> a clone of the deleted profile. Cloning is necessary because profiles are
         * created and deleted by the <code>GroupByList</code> that holds them without control from this
         * class.
         */
        public ProfileVO profile = null;
        /**
         * Creates a new object to contain the given profile, deleted from the specified file.
         * The profile is cloned before being stored in the resulting object.
         * @param file (<code>GUIFileVO</code>) that contained the profile
         * @param profile (<code>ProfileVO</code>) that was deleted
         */
        public DeletedItem (GUIFileVO file, ProfileVO profile){
            if(file==null || profile==null){
                throw new InternalError("Either file or profile parameter is null");
            }
            this.file = file;
            ArrayList elements = new ArrayList();
            elements.addAll(profile.getElements());
            this.profile = new ProfileVO(elements);
        }
    }
    /**
     * Creates a new command to act on the given <code>MainFrame</code>
     * @param frame (<code>MainFrame</code>) Where the actions of this command
     * will take effect
     */
    public DeleteProfileCommand(MainFrame frame){
        this.frame = frame;
    }
    /**
     * Returns a description of the executed command.
     * It's not used at all now (0.3.0) but will be used in the future
     * to show in the command list of the redo feature.
     * The value is taken from the "name" text resource of this class.
     * @see es.tunelator.gui.commands.Command#getName()
     */
    public String getName() {
        return Resourcer.getString(DeleteProfileCommand.class,"name");
    }
    /**
     * Executes this command, which implies:
     * <dir>
     * <li>Cancel the edition of table cells</li>
     * <li>Get the profiles selected on the tree</li>
     * <li>Remove the node of each profile from the tree</li>
     * <li>Retrieve from the tree node's user object the 
     * <code>ProfileVO</code></li>
     * <li>Create a new <code>DeletedItem</code> for each profile and save 
     * them in a list</li>
     * <li>Remove all the points in each profile from the point list of the 
     * file</li>
     * </dir>
     * The group list of the file is automatically regenerated by the event 
     * reaction mecanism of 
     * the <code>GroupByList</code> that implements it.
     * 
     * @see es.tunelator.gui.commands.Command#execute()
     */
    public void execute() throws UserMessageException {
        try {
	        JTree jTree = frame.getJTree();
	        frame.cancelTableEditing();
	        TreePath[] selectedNodes = jTree.getSelectionPaths();
	        for(int i=0; i<selectedNodes.length; i++){
	    		DefaultMutableTreeNode node = (DefaultMutableTreeNode)
	    			selectedNodes[i].getLastPathComponent();
	    		if((node != null) && (node.getLevel()==3)){
	    		    ProfileVO profileData = (ProfileVO) node.getUserObject();
	    		    DefaultMutableTreeNode fileNode = (DefaultMutableTreeNode)node.
	    		    	getParent();
	    		    GUIFileVO file = (GUIFileVO) 
	    		    	((FileNodeUpdater)fileNode.getUserObject()).
	    		    		getUserObject();
	    		    // The profile is not cloned because after beíng deleted it can
	    		    // not have changed. Otherwise we should use 
	    		    // profileData.clone()
	    		    DeletedItem backup = new DeletedItem(file,profileData); 
	    		    items.add(backup);
                    
	    		    // This commented line does not work properly when the table is 
	    		    // not sorted by the PKTeor column and a profile is deleted. 
	    		    // Some of the points in the profile are not deleted. A 
	    		    // NullPointerException raises at TableComparatorChooser when 
	    		    // it uses its sortedList attribute.
	    		    // file.getTableList().removeAll(profileData.getElements());
                    
	    		    // Have to call removeAll on the BasicEventList and NOT on any 
	    		    // of the TranformedList because else, it fires one event per 
	    		    // element removed instead of a single event for all.
	    		    file.getData().removeAll(backup.profile.getElements());
	    		}
	        }
			frame.resetEnablementStatus();
        } catch (Exception e) {
            Logger.logError(this.getClass(),e);
            throw new UserMessageException(Resourcer.getString(null,"error.internal"));
        }
    }
    /**
     * Undoes the effects that were provoked by the execution of this command.
     * This implies:
     * <dir>
     * <li>Recover each profile and the <code>GUIFileVO</code> that holded it 
     * from the <code>DeletedItem</code> list</li>
     * <li>Add all the points in the profile to the file
     * </dir>
     * The rest is done by the magic of the <code>EventList</code> lists that 
     * are used as underlying data structures, and communicate all changes 
     * between them and to the GUI widgets that must update themselves.
     * @see es.tunelator.gui.commands.Command#undo()
     */
    public void undo() throws UserMessageException {
        try {
	        Iterator it = items.iterator();
	        while(it.hasNext()){
	            DeletedItem item = (DeletedItem) it.next();
	            ProfileVO deletedProfile = item.profile;
	            item.file.getData().addAll(deletedProfile.getElements());
	        }
			frame.resetEnablementStatus();
        } catch (Exception e) {
            Logger.logError(this.getClass(),e);
            throw new UserMessageException(Resourcer.getString(null,
                    "error.internal"));
        }
    }
}
